/*
 * convolveQueue.c
 *
 *  Created on: Apr 23, 2016
 *      Author: Ben
 */

#include "convolveQueue.h"

/**
 * This file realizes the functions of the convolve queue.
 */

/***************************************************
            Methods
***************************************************/

/** Initialize the queue

 * Parameters:
 * @param pThis  pointer to own object
 * @param pChunk the chunk to start off the array with.
 *
 * @return Zero on success.
 * Negative value on failure.
 */
int convolveQueue_init(convolveQueue *pThis) {
	pThis->position = 0;
	return 0;
}

/**
 * Push the left and right audio samples from the chunk onto the
 * left and right arrays accordingly.
 *
 * @return Zero on success.
 * Negative value on failure.
 */
int convolveQueue_push(convolveQueue *pThis, chunk_d_t **pChunk) {
	unsigned int sampleNr = 0;
	    if ( NULL == pThis || NULL == pChunk ) {
	        printf("[TX]: Chunk/Audio objects not initialized \r\n");
	        return -1;
	    }


	    /* ISR/polled execution ? */
	    if ( 0 == pThis->running ) {
	    	unsigned int samplesInChunk = pChunk->bytesUsed/sizeof(unsigned int);

	    	/* Do polled transfer - by checking TX VACANCY in the FIFO */
	    	while( samplesInChunk > (*(volatile u32 *) (FIFO_BASE_ADDR + FIFO_TX_VAC)));

	    	for(sampleNr=0;sampleNr < samplesInChunk;sampleNr++) {
	        	*(volatile u32 *) (FIFO_BASE_ADDR + FIFO_TX_DATA) = ((unsigned int)pChunk->u16_buff[sampleNr]) << 16;
	        	*(volatile u32 *) (FIFO_BASE_ADDR + FIFO_TX_LENGTH) = 0x1;
	        }

	        /* chunk data has been copied into the TX FIFO, release chunk to the free list*/
	        bufferPool_d_release((pThis->pBuffP), pChunk);

	        /* Enable TX ISR mode */
	        pThis->running = 1;
	        return 0;
	    }

	pThis->left[pThis->position] =
}

/**
 * Return 1 if the convolve queue has reached the usable size.
 */
int convolveQueue_ready(convolveQueue *pThis);

/**
 * Allow the queue to pop an item off of each list.
 *
 * @return None
 */
void convolveQueue_pop(convolveQueue *pThis);

/**
 * Determines the number of sample readings that the left array has to be moved over for the
 * max value of the convolution of the arrays to appear.
 * Finds both the positive and negative number of times it has to be moved and then
 * returns the one with the least absolute value.
 *
 * @return the int phase diff.
 */
int convolveQueue_getSampleCountPhaseDiff(convolveQueue *pThis);
